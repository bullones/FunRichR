```{r}
# get ontology and enrichment type
if (LIST_LEVEL!="kegg"){
  ont_plot <- paste0("(", ONT, ")")
  list_plot <- "GOs"
} else {
  ont_plot <- NULL
  list_plot <- "KEGGs"
}
```


```{r}
# get TopGO
COUNTBG_CUTOFF <- 0.25
tmp <- data.frame()
for (i in 1:length(enrichment_list[[LIST_LEVEL]])){
  tmp <- rbind(tmp, enrichment_list[[LIST_LEVEL]][[i]]@result[enrichment_list[[LIST_LEVEL]][[i]]@result$p.adjust <= P_CUTOFF & enrichment_list[[LIST_LEVEL]][[i]]@result$qvalue <= Q_CUTOFF & enrichment_list[[LIST_LEVEL]][[i]]@result$CountBg >= COUNTBG_CUTOFF, c("ID", "CountBg")])
}
# length(unique(tmp$ID))
while (length(unique(tmp$ID)) > MAXTOPGOS) {
  COUNTBG_CUTOFF <- COUNTBG_CUTOFF + 0.05
  tmp <- tmp[tmp$CountBg >= COUNTBG_CUTOFF, ]
}

for (i in 1:length(enrichment_list[[LIST_LEVEL]])){
  enrichment_list[[LIST_LEVEL]][[i]]@result$TopGO <- enrichment_list[[LIST_LEVEL]][[i]]@result$CountBg >= COUNTBG_CUTOFF & enrichment_list[[LIST_LEVEL]][[i]]@result$p.adjust <= P_CUTOFF & enrichment_list[[LIST_LEVEL]][[i]]@result$qvalue <= Q_CUTOFF
}
```

Assign colors to the TF for the ggplot.

```{r, eval=EVAL_TF, include=EVAL_TF}
# edit tf variable to assign colors
tf_edited <- tf$Gene_ID
tf_edited <- sort(tf_edited)
tf_edited <- unique(tf_edited)
tf_edited <- as.data.frame(tf_edited)
tf_edited$type <- "tf"
colnames(tf_edited)[1] <- "ID"
# merge tf and other_genes_arab to assign colors
if (exists("tf_edited") & exists("other_genes_arab")) {
  tf_and_other <- rbind(tf_edited, other_genes_arab)
  # get a vector of repeated IDs
  repeated <- data.frame(table(tf_and_other$ID))
  repeated <- repeated[repeated$Freq > 1, ]
  repeated <- as.vector(repeated$Var1)
  # remove them from the dataframe
  if (length(repeated) > 0) {
    tf_and_other <- tf_and_other[!tf_and_other$ID %in% repeated, ]
    # add them again
    repeated <- as.data.frame(repeated)
    repeated$type <- "both"
    colnames(repeated)[1] <- "ID"
    tf_and_other <- rbind(tf_and_other, repeated)
  }
} else tf_and_other <- tf_edited
# assign colors
ggcolors <- list() # ggcolors is created in each iteration. Should I keep it??!!
ggcolors[[LIST_LEVEL]] <- list()
for (i in 1:length(enrichment_list[[LIST_LEVEL]])) {
  # keep result field for each element in the list
  tmp <- enrichment_list[[LIST_LEVEL]][[i]]@result
  # add new column to save TF results
  enrichment_list[[LIST_LEVEL]][[i]]@result$TF <- NA
  name <- names(enrichment_list[[LIST_LEVEL]][i])
  ggcolors[[LIST_LEVEL]][[name]] <- list()
  for (j in 1:length(rownames(tmp))) {
    # get j geneID and compare it with the TF list
    tmp2 <- tmp[j,]$geneID
    tmp2 <- unlist(strsplit(tmp2, "/"))
    # assign TFs and add them to the enrichment object
    tmp3 <- merge(x = as.data.frame(tmp2),
                  y = tf,
                  by.x = 1,
                  by.y = 2)
    tmp3 <- unique(tmp3[, -2])
    tmp3 <- tmp3$Family
    tmp3 <- tmp3[order(tmp3)]
    # add those TF to the enrichment object
    if (!is_empty(tmp3)) {
      tmp3 <- paste0(tmp3, collapse = "|") # we use | instead of / because one of the TF's name has a /
      enrichment_list[[LIST_LEVEL]][[i]]@result$TF[[j]] <- tmp3
      } # end if
    # assign colors for the ggplot
    tmp4 <- merge(x = as.data.frame(tmp2),
                  y = tf_and_other,
                  by = 1)
    tmp4 <- tmp4$type
    # assign pink if a process has both TF and other genes
    if (any(tmp4 == "both") | (any(tmp4 == "tf") && any(tmp4 == "other_genes"))) {ggcolors[[LIST_LEVEL]][[i]] <- append(ggcolors[[LIST_LEVEL]][[i]], setNames("Both categories", tmp[j,]$Description))
      } else { # assign orange if it's TF
        if (any(tmp4 == "tf")) {
          ggcolors[[LIST_LEVEL]][[i]] <- append(ggcolors[[LIST_LEVEL]][[i]], setNames("Transcription factors", tmp[j,]$Description))
          } else { # assign purple if it's other gene
            if (any(tmp4 == "other_genes")) {
              ggcolors[[LIST_LEVEL]][[i]] <- append(ggcolors[[LIST_LEVEL]][[i]], setNames("Genes of interest", tmp[j,]$Description))
            } else { # assign green if none of the above
              ggcolors[[LIST_LEVEL]][[i]] <- append(ggcolors[[LIST_LEVEL]][[i]], setNames("None", tmp[j,]$Description))
              } # end else purple
            } # end else orange
      } # end else pink
    # names(ggcolors[[LIST_LEVEL]][[i]][j]) <- tmp[j,]$Description # this doesn't work
    } # end for j
  } # end for i
```

```{r}
#0.12*ENRICH_FACTOR
height_plots <- c()
for (i in 1:length(enrichment_list[[LIST_LEVEL]])) {
  height_plots <- append(height_plots, (nrow(enrichment_list[[LIST_LEVEL]][[i]])))
  height_plots <- max(height_plots)
}
if (height_plots<25){
  height_plots <- 25
}
```

### Dotplot

```{r, fig.show = "hold", out.width = "50%", fig.height=ceiling(0.16*height_plots), fig.width=5}
for (i in 1:length(enrichment_list[[LIST_LEVEL]])) {
  tmp <- enrichment_list[[LIST_LEVEL]][[i]]
  # if we are NOT plotting KEGGs, we will filter them
  MIN_GENES <- trunc(number_genes_enrichment[[LIST_LEVEL]][[i]]/ENRICH_FACTOR)
  if (MIN_GENES == 0 || LIST_LEVEL=="kegg") {
    MIN_GENES <- 1
  } # end if
  tmp2 <- tmp$Count >= MIN_GENES
  # if no process passes the filter, we plot all of them
  if (!any(tmp2)) {
    tmp2 <- tmp$Count >= 0
  } # end if
  # check if we have any process. If not, skip
  if (!any(tmp2)) {
    next
  } # end if
  tmp3 <- tmp[tmp2]$Description
  
  # dotplot
  set.seed(SEED)
  p_dp <- dotplot(enrichment_list[[LIST_LEVEL]][[i]],
                    showCategory = tmp3, # seleccionamos cuántos procesos
                    font.size = 6,
                    label_format = 80) + # sets wrap length
      ggtitle(paste0(names(enrichment_list[[LIST_LEVEL]][i]), " enriched ", list_plot, " ", ont_plot)) +
      theme(plot.title = element_text(hjust = 0.9))
  print(p_dp)
  
    # dotplot TOPGO
  tmp4 <- tmp@result$Description[tmp@result$TopGO]
  set.seed(SEED)
  if (length(tmp4)){
    p_dp <- dotplot(enrichment_list[[LIST_LEVEL]][[i]],
                    showCategory = tmp4, # seleccionamos cuántos procesos
                    font.size = 6,
                    label_format = 80) + # sets wrap length
      ggtitle(paste0("Top (", round(COUNTBG_CUTOFF*100, 2), " %) ", list_plot," in ", names(enrichment_list[[LIST_LEVEL]][i]), " ", ont_plot)) +
      theme(plot.title = element_text(hjust = 0.9))
  print(p_dp)
  } else {
    plot(1, 1, main = "No Top GO to plot")
  }
  
  # p_bp <- mutate(enrichment_list[[LIST_LEVEL]][[i]],
  #                qscore = -log(p.adjust, base=10)) |>
  #   barplot(x="qscore",
  #           showCategory = tmp,
  #           font.size = 6,
  #           label_format = 80) +
  #   ggtitle(paste0(names(enrichment_list[[LIST_LEVEL]][i]), " enriched GOs (", ONT, ")")) +
  #     theme(plot.title = element_text(hjust = 0.9))
  # 
  #   print(heatplot(enrichment_list[[LIST_LEVEL]][[i]],
  #            showCategory=5))
}
```

### Treeplot

```{r}
warning("Be careful with the interpretation of treeplots: if there are more than 10 clusters, the processes might be wrong placed")
```


```{r}
#0.15*ENRICH_FACTOR
if (height_plots<20){
  height_plots <- 20
}
```

```{r, fig.show = "hold", out.width = "50%", fig.height=ceiling(0.20*height_plots), fig.width=18, warning=FALSE, message=FALSE}
for (i in 1:length(enrichment_list[[LIST_LEVEL]])) {
  tmp <- enrichment_list[[LIST_LEVEL]][[i]]
  MIN_GENES <- trunc(number_genes_enrichment[[LIST_LEVEL]][[i]]/ENRICH_FACTOR)
  if (MIN_GENES == 0 || LIST_LEVEL=="kegg") {
    MIN_GENES <- 1
    } # end if
  tmp2 <- tmp$Count >= MIN_GENES
  # if no process passes the filter, we plot all of them
  if (!any(tmp2)) {
    tmp2 <- tmp$Count >= 0
    } # end if
  # check if we have any process. If not, skip
  if (!any(tmp2)) {
    next
    } # end if
  tmp <- tmp[tmp2]$Description
  
  # treeplot
  set.seed(SEED)
  tmp_tree <- pairwise_termsim(enrichment_list[[LIST_LEVEL]][[i]],
                               showCategory = nrow(enrichment_list[[LIST_LEVEL]][[i]]))
  # to get the number of clusters
  if (nrow(tmp_tree) >1){ # check if we have genes to cluster
    if (NCLUST_USER == 0){ # to recalculate in each iteration
      mat <- tmp_tree@termsim # ONLY HAS UPPER TRIANGLE
      tmat <- t(mat)
      mat[lower.tri(mat)] <- tmat[lower.tri(tmat)] # complete lower triangle
      mat[is.na(mat)] <- 1 # set diagonal to 1
      mat_dist <- as.dist(mat)
      mat_tree <- hclust(mat_dist, method = "ward.D")
      group_dynamic <- cutreeDynamic(dendro = mat_tree,
                                     distM = as.matrix(mat_dist),
                                     minClusterSize = 20)
      names(group_dynamic) <- mat_tree$labels
      dynamic_k <- length(table(group_dynamic))
      NCLUST <- dynamic_k
      } else {
        NCLUST <- NCLUST_USER
      }
  } else { # print message and go to next iteration
    print(paste0("Only one ", LIST_LEVEL," enrichment term found for ", names(enrichment_list[[LIST_LEVEL]][i]), ": ", tmp, ". No treeplot will be plotted"))
      next
    }
  # treeplot
  p_tp <- treeplot(tmp_tree,
                   showCategory = length(tmp),
                   fontsize = 3,
                   nCluster = NCLUST,
                   # label_format_tiplab = 35,
                   cluster.params = list(label_words_n = 5, label_format = 30)) +
    ggtitle(paste0(names(enrichment_list[[LIST_LEVEL]][i]), " enriched ", list_plot, " ", ont_plot)) +
    theme(plot.title = element_text(hjust = 0.9))
  print(p_tp)
}
```

### Heatmap

```{r, warning=FALSE}
# calculate heatmap
# save first iteration to merge later using a for loop
tmp_CountBg <- enrichment_list[[LIST_LEVEL]][[1]]@result[enrichment_list[[LIST_LEVEL]][[1]]@result$TopGO, c("Description", "CountBg")]
if (length(enrichment_list[[LIST_LEVEL]])>1){
  for (i in 2:length(enrichment_list[[LIST_LEVEL]])){
    tmp_CountBg <- merge(tmp_CountBg,
                         enrichment_list[[LIST_LEVEL]][[i]]@result[enrichment_list[[LIST_LEVEL]][[i]]@result$TopGO, c("Description", "CountBg")],
                         by = "Description",
                         all  = TRUE)
  } # end for
} # end if

if (nrow(tmp_CountBg)) {
  rownames(tmp_CountBg) <- tmp_CountBg$Description
  tmp_CountBg$Description <- NULL
  tmp_CountBg[is.na(tmp_CountBg)] <- 0
  colnames(tmp_CountBg) <- names(enrichment_list[[LIST_LEVEL]])
  tmp_CountBg[, grepl("<", colnames(tmp_CountBg))] <- tmp_CountBg[, grepl("<", colnames(tmp_CountBg))] * -1
  #calculate height and width
  height <- ceiling(0.17*nrow(tmp_CountBg))
  width <- ceiling(0.8*ncol(tmp_CountBg))
  # minumum width 5
  if (width < 5) {
    width <- 5
  } # end if width
  # minumum height 5
  if (height < 2) {
    height <- 2
  } # end if height
  
  # Truncar los nombres a 90 caracteres + "..."
  truncated_names <- sub("^(.{90}).*", "\\1...", rownames(tmp_CountBg), perl = TRUE)
  
  # Asegurar unicidad añadiendo un sufijo numérico a los duplicados
  make_unique <- function(names) {
    dups <- duplicated(names)  # Vector lógico de duplicados
    counts <- table(names)  # Contar ocurrencias
    suffix <- rep(1, length(names))  # Inicializar sufijos
    
    for (i in seq_along(names)) {
      if (dups[i]) {  # Si hay duplicado
        base_name <- names[i]
        while (base_name %in% names[1:(i - 1)]) {  # Buscar sufijo único
          suffix[i] <- suffix[i] + 1
          base_name <- paste0(sub("\\.\\.\\.$", "", names[i]), "_", suffix[i], "...")
        } # end while
        names[i] <- base_name
      } # end if dups
    } # end for
    return(names)
  } # end function
  
  rownames(tmp_CountBg) <- make_unique(truncated_names)
} else { # define heigth and width to avoid next chunck to fail
  width <- 5
  height <- 2
}
```

```{r, fig.height=height, fig.width=width, warning=FALSE}
if (nrow(tmp_CountBg)) {
# order pheatmap according to GOs frequency
  row_order <- order(rowSums(tmp_CountBg != 0), decreasing = TRUE)
  tmp_CountBg <- tmp_CountBg[row_order, ]
  
  # plot heatmap son width and height are calculated
  max_abs <- max(abs(c(min(tmp_CountBg), max(tmp_CountBg))))
  breaks <- seq(-max_abs, max_abs, length.out = 12)
  pheatmap(as.matrix(tmp_CountBg),
           cluster_cols = FALSE,
           cluster_rows = FALSE,
           fontsize = 6,
           color = colorRampPalette(c("red", "white", "yellow"))(length(breaks) - 1),
           breaks = breaks)
} else {
  message("No Top GO to plot")
}
```

### Network

```{r, fig.show = "hold", out.width = "50%", fig.height=6, fig.width=6}
network_plots <- list()
network_plots[[LIST_LEVEL]] <- list()
for (i in 1:length(enrichment_list[[LIST_LEVEL]])) {
  tmp <- enrichment_list[[LIST_LEVEL]][[i]]
# if we are NOT plotting KEGGs, we will filter them
  MIN_GENES <- trunc(number_genes_enrichment[[LIST_LEVEL]][[i]]/ENRICH_FACTOR)
  if (MIN_GENES == 0 || LIST_LEVEL=="kegg") {
    MIN_GENES <- 1
    } # end if
  tmp2 <- tmp$Count >= MIN_GENES
  # if no process passes the filter, we plot all of them
  if (!any(tmp2)) {
    tmp2 <- tmp$Count >= 0
    } # end if
  # check if we have any process. If not, skip
  if (!any(tmp2)) {
    next
    } # end if
  tmp3 <- tmp[tmp2]$Description
  
  # network
  set.seed(SEED)
  p_nt <- emapplot(pairwise_termsim(enrichment_list[[LIST_LEVEL]][[i]]),
                   showCategory = length(tmp3), # seleccionamos cuántos procesos
                   # cex_label_category = 0.5, # tamaño etiquetas nodos
                   node_label = "none") + # quitar etiquetas 
            ggtitle(paste0(names(enrichment_list[[LIST_LEVEL]][i]), " enriched ", list_plot, " ", ont_plot))
    print(p_nt)
    network_plots[[LIST_LEVEL]][[names(enrichment_list[[LIST_LEVEL]][i])]] <- p_nt
}
```

### Interactive network

```{r, fig.show = "hold", out.width = "50%", fig.height=6, fig.width=6}
plt <- htmltools::tagList()
plt[[LIST_LEVEL]] <- htmltools::tagList()

if (length(network_plots[[LIST_LEVEL]]) != 0){
  if (exists("ggcolors")) {
    # legend_colors <- c("Transcription factors" = "orange",
    #                    "Genes of interest" = "purple",
    #                    "Both categories" = "yellow",
    #                    "None" = "green")
    for (i in 1:length(network_plots[[LIST_LEVEL]])) {
      # keep network_plots data
      tmp <- network_plots[[LIST_LEVEL]][[i]]$data
      tmp <- tmp[, 1:3]
      # keep ggcolors data
      tmp2 <- as.data.frame(unlist(ggcolors[[LIST_LEVEL]][[i]]))
      # merge both of them
      tmp3 <- merge(x = tmp,
                    y = tmp2,
                    by.x = 3,
                    by.y = "row.names")
      colnames(tmp3)[4] <- "categories"
      set.seed(SEED)
      p_nt_int <- ggplot(tmp3,
                         aes(x = x, y = y, name = name)) +
          geom_point(aes(color = categories), size = 2) +
        scale_color_manual(name = "Processes including:",
                           breaks = c("Transcription factors", "Genes of interest", "Both categories", "None"),
                           values = c("Transcription factors" = "orange", "Genes of interest" = "purple", "Both categories" = "yellow", "None" = "green")) +
        # scale_color_manual(values = unlist(ggcolors[[LIST_LEVEL]][[i]]),
        #                    limits = force) + # define colors with ggcolors
        # theme(legend.position = "bottom") + # it doesn't work with ggplotly
          ggtitle(paste0(names(network_plots[[LIST_LEVEL]][i]), " enriched ", list_plot, " ", ont_plot))
        plt[[LIST_LEVEL]][[i]] <- as_widget(ggplotly(p_nt_int,
                                              height = 600,
                                              width = 600))
    } # end for
  }else {
    for (i in 1:length(network_plots[[LIST_LEVEL]])) {
    # keep network_plots data
      tmp <- network_plots[[LIST_LEVEL]][[i]]$data
      tmp <- tmp[, 1:3]
      set.seed(SEED)
      p_nt_int <- ggplot(tmp,
                         aes(x = x, y = y, name = name)) +
          geom_point(aes(color = "#0099f9"), size = 2) +
        theme(legend.position = "none") +
          ggtitle(paste0(names(network_plots[[LIST_LEVEL]][i]), " enriched ", list_plot, " ", ont_plot))
        plt[[LIST_LEVEL]][[i]] <- as_widget(ggplotly(p_nt_int,
                                              height = 600,
                                              width = 600))
    } # end for
  } # end else
} # end if
```

```{r, echo=FALSE, fig.show = "hold", out.width = "50%", fig.height=6, fig.width=6}
if (length(network_plots[[LIST_LEVEL]]) != 0) {
  plt
}
```

### Wordclouds by words

```{bash, engine.opts='-l', results='hide'}
# remove wordclouds directory
rm -r wordclouds
# create wordclouds directory
mkdir wordclouds
```

Get stopwords.

```{bash, engine.opts='-l', results='hide', eval=FALSE, include=FALSE}
# Obtain stopwords
curl -sL "https://raw.githubusercontent.com/stopwords-iso/stopwords-en/master/stopwords-en.txt" |
# sort stopwords and save as "stopwords"
sort | 
# save stopwords in the file stopwords-en using tee instead of ">"
tee ../stopwords-en | 
# show the first 4 words
head -n 4
```

Create the text for the wordcloud graph.

```{r}
for (i in 1:length(enrichment_list[[LIST_LEVEL]])) {
  # create data.frame with GO term frequency
  wcdf <- read.table(text = enrichment_list[[LIST_LEVEL]][[i]]$GeneRatio,
                     sep = "/")[1]
  names(wcdf)[1] <- "GeneRatio"
  # add GO term column
  wcdf$term <- enrichment_list[[LIST_LEVEL]][[i]][,2]
  # convert wcdf to text
  mytext <- c()
  mytext <- append(rep(wcdf$term, wcdf$GeneRatio), mytext)
  mytext <- paste(mytext, collapse = " ")
  mytext <- toString(mytext)
  
  # remove punctuation signs
  mytext <- gsub("[[:punct:]]", "", mytext)
  
  # save it to work with bash
  write.table(mytext,
              file = paste0("wordclouds/",
                            names(enrichment_list[LIST_LEVEL]),
                            "_",
                            names(enrichment_list[[LIST_LEVEL]][i]),
                            ".tsv"))
  }
```

EXPLICAR

```{bash, message = FALSE, results='hide'}
for file in wordclouds/*.tsv;
do
cat $file |
# converting text to lowercase
tr '[:upper:]' '[:lower:]' |
# extract words and put the on separate line
grep -oE "[a-z\']{2,}" |
# sort in alphabetical order
sort |
# select non-matching lines
grep -Fvwf ../stopwords-en-edited |
# remove all the duplicates and count frequency
uniq -c |
# sort the list by count
sort -nr |
# save the file
tee $file.wc |
# show top 4 lines
head -n 4
# remove $file
rm $file
done
```

EXPLICAR

```{r, fig.show = "hold", out.width = "50%", fig.height=6, fig.width=6}
# load all the variables for wc
filenames <- list.files(paste0(SOURCE_DIR, "Rmd/wordclouds"),
                        pattern = "*.wc",
                        full.names = TRUE)
ldf <- lapply(filenames, read.table)

filenames <- gsub(".*/", "", filenames)
filenames <- gsub(".tsv.wc", "", filenames)
names(ldf) <- filenames

for (i in 1:length(ldf)) {
  words_df <- ldf[[i]]
  words_df <- words_df[, c(2,1)]
  # MIN_FREQ <- max(words_df[[2]])/MIN_RATIO
  set.seed(SEED)
  wordcloud(words = words_df[[1]],
            freq = words_df[[2]],
            scale = c(4, .5),
            random.order = FALSE,
            rot.per = 0, # % of vertical words
            min.freq = 2,
            max.words = Inf,
            colors = brewer.pal(8, "Dark2")[-(1:2)])
  title(names(ldf[i]), line = 2) # position of the title
}
```

Remove temporal wordcloud data

```{bash}
rm -r wordclouds
```

### Wordclouds by terms

```{r, fig.show = "hold", out.width = "50%", fig.height=6, fig.width=6}
for (i in 1:length(enrichment_list[[LIST_LEVEL]])) {
  wcdf <- read.table(text = enrichment_list[[LIST_LEVEL]][[i]]$GeneRatio,
                     sep = "/")[1]
  names(wcdf)[1] <- "GeneRatio"
  # add GO term column
  wcdf$term <- enrichment_list[[LIST_LEVEL]][[i]][,2]
  # calculate MIN.FREQ
  MIN_FREQ <- max(wcdf$GeneRatio)/MIN_RATIO
  set.seed(SEED)
  wordcloud(words = wcdf$term,
            freq = wcdf$GeneRatio,
            scale = c(.8, .3),
            random.order = FALSE,
            rot.per = 0, # % of vertical words
            min.freq = MIN_FREQ,
            max.words = Inf,
            colors = brewer.pal(8, "Dark2")[-(1:2)])
  title(names(enrichment_list[[LIST_LEVEL]][i]), line = 2)
}
``` 
